/*
 * DesignPath's primary purpose is to be an embroidery-sensitive wrapper 
 * around Paper.js' path object.
 * Note that Paper.js' path is made up of "segments" rather than points.
 * However, Path's can be initialized with lists of Paper.js points
 * 
 * DesignPath is primarily a container to be edited by Design.
 * However, DesignPath does handle translating its paperPath to a sewing path
 */

var DesignPath = function(pPath){
	if (pPath == undefined || pPath == null)this.paperPath = new Path();
	else this.paperPath = pPath;
	
	this.derivitivePaths = {
		simplifiedPath: null, // this.paperPath.simplify()
		flattenedPath: null, // this.paperPath.flatten()
		designPath: null // generated by design.js
	}
	// If derivitive paths are dirty, ie the paperPath has been changed
	// We need to know to regenerate stuff
	// We also need to know when it's safe to regenerate the design path
	this.dirtyPaths = {
		simplifiedPath: true,
		flattenedPath: true,
		designPath: true
	}
	
	this.lastUsedParams = {};
	
	this.stitchLengthMM = 2;
	this.pixelsPerMM = 10;
	// this is a MAX length. any uneven length is distributed between the ceiling of the division
	this.stitchLengthPixels = undefined;
	this.setSewnStitchLength(this.stitchLengthMM, this.pixelsPerMM);
	
	return this;
}; // DesignPath

/////////////////////////////////////////////////////////
//// GETTERS /////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////

DesignPath.prototype.getPPath = function(){
	return this.paperPath;
}; // getPPath

DesignPath.prototype.getPathPoints = function(path){
	if(path == null){
		console.log("no path specified in getPathPoints, using default paperPath");
		path = this.paperPath;
	};
	
	var points = [];
	
	for(var i = 0, i < path.segments.length; i++){
		points.push(path.segments.point.clone());
	}
	return points;
};

// TO DO: ADDITIONAL PARAMS: USE OLD PARAMS?
DesignPath.prototype.getSimplifiedPath = function(params){
	if(this.dirtyPaths.simplifiedPath == true){
		this.generateSimplifiedPath(params);
	}
	
	return this.derivitivePaths.simplifiedPath;
};

// TO DO: ADDITIONAL PARAMS: USE OLD PARAMS?
DesignPath.prototype.getFlattenedPath = function(params){
	
	if(this.dirtyPaths.simplifiedPath == true ||
		this.dirtyPaths.flattnedPath == true){
		this.generateFlattenedPath(params);
	}
	
	return this.derivitivePaths.flattenedPath;
	
};

// Params: path is null or paper.js path
// Pre: this.stithLengthPixels is set by this.setSewnStitchLength
// Return: A list of x,y points based on a specific preset scale
DesignPath.prototype.getSewnPath = function(path){
	if(path == null){
		console.log("no path specified in getSewnPath, using default paperPath");
		path = this.paperPath;
	}
	
	if(path == null){
		console.err("Cannot getSewnPath for a null path, even paperPath", path);
		return;
	}
	if(path.length <= 1){
		console.err("Cannot getSewnPath for a path of <= 1 pixel distance", path);
		return;
	}
	if(path.segments.length <= 1){
		console.err("Cannot getSewnPath for a path of 0 or 1 segments", path);
		return;
	}
	
	var plottedPoints = [];
	console.log("plotting", path);
	console.log("Path length // this.stitchLengthPixels", path.length, this.stitchLengthPixels);
	var numPoints = Math.ceil(path.length/this.stitchLengthPixels); // Makes sure all is <= stitchLengthPixels
	console.log("fits # of points (without endpoint)", numPoints);

	// loops for numPoints+1 for the endpoint, which should be at offset = path.length (i and numPoints cancel each other out)
	for(var i = 0; i <= numPoints; i++){
		var offset = (path.length/numPoints) * i;
		var point = path.getPointAt(offset);
		console.log("Plotted point 1 by offset", i, offset, point);
		plottedPoints.push(point);
	}

	
	console.log("plotted sewn points on disance", plottedPoints);
	return plottedPoints;
};

///////////////////////////////////////////////////////////////////
//////////// SETTERS //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

// Sets the flags that all paths should be re-generated
// Should be called when this.paperPath is changed
DesignPath.prototype.setAllPathsDirty = function(){
	for (var key in this.dirtyPaths) {
	    // skip loop if the property is from prototype
	    if (!this.dirtyPaths.hasOwnProperty(key)) continue;
	
	    this.dirtyPaths[key] = true;
    }

};

// stitchLength is in mm
// pixelsPerMM is the screen -> stitchLength scale conversion
// pixelsPerMM should always be a number >1 (otherwise jesus how tiny is this path/screen? Oh, but that's an idea....)
DesignPath.prototype.setSewnStitchLength = function(stitchLengthMM, pixelsPerMM){
	this.stitchLengthMM = stitchLengthMM;
	this.pixelsPerMM = pixelsPerMM;

	this.stitchLengthPixels = stitchLengthMM * pixelsPerMM; 

	console.log("Stitch Length Properties Set: " + this.stitchLengthMM + " * " + this.pixelsPerMM + " = " + this.stitchLengthPixels);
};

// Args: path is a paper.js path
// Pre: none
// Post: this.paperPath is set to the path
//       all derivitive paths are marked as dirty
DesignPath.prototype.setNewPaperPath = function(path){
	if(path == null){
		console.log("setting a null path in setNewPaperPath?", path);
	}
	// Clean up old path
	if(this.paperPath !== null) {
		this.paperPath.remove();
	}
	// set new path
	this.paperPath = path;
	// set dirty
	this.setAllPathsDirty();
};

/////////////////////////////////////////////////////////////////
///// COMPUTE PATHS ////////////////////////////////////////////
////////////////////////////////////////////////////////////////

// Pre: this.paperPath is not null, otherwise return 
// Post: this.derivitivePaths.simplifiedPath is set if this.paperPath is not null
//       this.dirtyPaths.simplifiedPath = false
DesignPath.prototype.generateSimplifiedPath = function(params){
	// Check dependencies
	if(this.paperPath === null){
		console.err("Should not be calling generateSimplifiedPath without a paperPath");
		return;
	}
	
	// clean up old, dirty path
	if(this.derivitivePaths.simplifiedPath !== null){
		this.derivitivePaths.simplifiedPath.remove();
		this.derivitivePaths.simplifiedPath = null;
	}
	
	// GENERATE IT
	this.derivitivePaths.simplifiedPath = this.paperPath.clone();
	
	if(params === undefined || params.tolerance === undefined){
		console.log("using default path settings in generateSimplifidPath", params);
		// Part of Paper.js
		this.derivitivePaths.simplifiedPath.simplify();
	} else {
		this.lastUsedParams.tolerance = params.tolerance;
		this.derivitivePaths.simplifiedPath.simplify(params.tolerance);
	}
	
	// FLAG IS NOW CLEAN
	this.dirtyPaths.simplifediPath = false;
};

// Pre: paperPath is not null, otherwise return 
//      simplifiedPath !== null or dirty, otherwise generate it
// Post: this.derivitivePaths.simplifiedPath is set if this.paperPath is not null
//       this.dirtyPaths.simplifiedPath = false

DesignPath.prototype.generateFlattenedPath = function(params){
	// Check dependencies
	if(this.paperPath === null){
		console.err("Should not be calling generateFlattenedPath without a paperPath");
		return;
	}
	
	if(this.derivitivePaths.simplifiedPath === null ||
		this.dirtyPaths.simplifiedPath == true){
		console.log("generateFlattenedPath with a null or dirty simplifiedPath, regenerate that first");
		this.generateSimplifiedPath(params);
		if(this.deritivitePaths.simplifiedPath === null){
			console.err("BAD BAD simplifiedPath is failing to be made, GTFO", this.derivitivePaths);
			return;
		}
		
	}
	
	// clean up old, dirty path
	if(this.derivitivePaths.flattenedPath !== null){
		this.derivitivePaths.flattenedPath.remove();
		this.derivitivePaths.flattenedPath = null;
	}
	
	// GENERATE IT
	this.derivitivePaths.flattenedPath = this.derivitivePaths.simplifiedPath.clone();
	
	if(params === undefined || params.flatness === undefined){
		console.log("using default path settings in generateFlattenedPath");
		//  Part of Paper.js
		this.derivitivePaths.flattenedPath.flatten(); // default is 2.5, maximum error
	} else {
		this.lastUsedParams.flatness = params.flatness;
		this.derivitivePaths.flattenedPath.flatten(params.flatness);
	}
	
	// FLAG IS NOW CLEAN
	this.dirtyPaths.flattnedPath = false;
};

